![бипбоп](https://media.tenor.com/A44ug7s67TEAAAAC/food-noodles.gif) 

---


В рамках домашней работы №1 требуется программно Реализовать в виде программы абстрактный тип данных «Дерево» согласно варианту. 
Пусть А, В, С – деревья соответствующего типа, узлы которых могут содержать целочисленные значения.
Требуется реализовать начальное формирование деревьев А и В, путем добавления некоторой последовательности значений (узлов) в пустое дерево.
После чего требуется по варианту реализовать заданную операцию над деревьями без использования каких-либо вспомогательных структур работая только с узлами деревьев А и В. 

---
Операция А=A ⋃прB означает, что элементы дерева В будут добавлены в дерево А в прямом порядке обхода дерева В, соответственно А=A ⋃обрB  – в обратном, а А=A ⋃симB  – симметричном обходе дерева В.

Операция А = A ⋂ B означает, что из дерева А исключаются узлы, отсутствующие в дереве В.

---


---

Реализовать задание (заданный алгоритм) с использованием методов АТД «Деревья двоичного поиска» 
---

| вар | Тип дерева| Вывод деревьев на экран | Алгоритм |
| --- | --- | --- | --- |
| №46 | Оптимальное дерево двоичного поиска, А–обратный, В – симметричный | Левый сын, правый брат (таблица, массив) | С=A ⋃прB |
---
## Теоритическая часть
### Оптимальное древо поиска
***Дерево поиска*** называется оптимальным, если его цена минимальна. То есть оптимальное бинарное дерево поиска –это бинарное дерево поиска, построенное в расчете на обеспечение максимальной производительности при заданном распределении вероятностей поиска требуемых данных.
Существует подход построения оптимальных деревьев поиска, при котором элементы вставляются в порядке уменьшения частот, что дает в среднем неплохие деревья поиска. Однако этот подход может дать вырожденное дерево поиска, которое будет далеко от оптимального. Еще один подход состоит в выборе корня k таким образом, чтобы максимальная сумма вероятностей для вершин левого поддерева или правого поддерева была настолько мала, насколько это возможно. Такой подход также может оказаться плохим в случае выбора в качестве корня элемента с малым значением pk. 
Припишем каждой вершине дерева Vi вес wi, 
пропорциональный частоте поиска этой вершины. Сумма 
весов всех вершин дает вес дерева W. Каждая вершина Vi расположена на высоте hi, корень расположен на высоте 1. 
Высота вершины равна количеству операций сравнения, необходимых для поиска этой вершины. Определим средневзвешенную высоту дерева с n вершинами следующим образом:
h_{ср}=(w_1h_1+w_2h_2+...+w_n+h_n)/W
Дерево поиска, имеющее минимальную средневзвешенную высоту, называется деревом оптимального поиска.
***Пример.*** Рассмотрим множество из трех ключей V1=1, V2=2, V3=3 со следующими весами: w1=60, w2=30, w3=10, W=100. Эти три ключа можно расставить в дереве поиска пятью различными способами.
![Пример](https://github.com/sl4sh73r/programming_technologies_and_methods/blob/main/прак%203/OBST_BE_LIKE.jpg) 
---
